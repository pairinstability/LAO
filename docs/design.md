Design oveview
===

The expectation is that this won't replace industrial-grade libraries such as Eigen; this is simply a fun project.

Efficiency
===

With polymorphism, an emphasis is placed on static rather than dynamic. There are no virtual calls, instead expression templates are used with CRTP. There is extensive bounds and type checking of matrices at compile-time as well.

Row-major ordering is performed. In the future, column-major will be an option.

Dense and sparse matrices require different allocation strategies, as using the same strategy yields drastic inefficiencies with sparse matrices. However, they both inherit from the same base class to provide primitives and interoperability.

Parallelism is supported with optional SIMD operations, with a default fallback to normal, non-parallel operations.

For mathematics operations, expression templates are used to achieve delayed evaluation. When performing mathematics operations, expression trees are built.


Classes and aliases
===


`DenseMatrix<typename Scalar, size_t Rows, size_t Cols>`
---

Class for dense matrices, stored in row-major form.

Note that a vector is a variation of a matrix with either a single row or single column. As such, both vectors and matrices are constructed with the `Matrix` class. However, some member functions may not work and will throw an exception. Use common sense.

For now, matrix size is determined at compile-time. Runtime support will be added.

Currently dense matrices are backed by `std::vector`. Ideally, `std::mdspan` but thats a C++23 feature that isn't supported by all compilers.


specializations:
- `Vector`
- `Symmetric`
- `Hermitian`
- `Triangular`

These specializations only modify the allocator to make use of more efficient allocation strategies for these particular matrix types.


constructors:

- `Matrix()`
- `Matrix(initializer_list)`
- `Matrix(filltype)`
- `Matrix(Matrix)`

For the default constructor, the elements are initialized to 0. 


`filltype` is an enum of possible types to fill the matrix with:

- `fill::zeros`
- `fill::ones`
- `fill::eye`
- `fill:rand`
- `fill::value(scalar)`
- `fill::none`


operators:

- `+` addition of two matrices.
- `-` subtraction of two matrices, or negation.
- `*` matrix multiplication.
- `%` element-wise multiplication.
- `==` element-wise equality evaluation.
- `!=` element-wise non-equality evaluation.
- `>=` element-wise greater than or equal to evaluation.
- `<=` element-wise less than or equal to evaluation.
- `>` element-wise greater than evaluation.
- `<` element-wise less than evaluation.


member functions:

- `rows()` returns number of rows.
- `cols()` returns number of cols.
- `is_empty()` returns if the matrix is empty.
- `zeros()` sets all elements to zero.
- `ones()` sets all elements to ones.
- `eye()` sets all elements on the main diagonal to 1, all else to 0.
- `rand()` sets all elements to random values, using a normal distribution in the `[0,1]` interval.
- `fill(value)` sets all elements to value. The type must match the type of elements used in the container.
- `fillf(lambda)` sets all elements to a value generated by a supplied lambda function or functor.
- `reset()` sets the size to 0, removing all elements.
- `submat(first row, first col, last row, last col)` submatrix view.
- `cview(col number)` submatrix view of a column.
- `rview(row number)` submatrix view of a row.
- `cviews(first col, last col)` submatrix view of multiple columns.
- `rviews(first row, last row)` submatrix view of multiple rows.



`SparseMatrix<typename Scalar, size_t Rows, size_t Cols>`
---

Class for sparse matrices, stored in row-major form. It is similar to the dense matrix class, except the member methods which set all elements to non-zero values are removed, and there is no fill or list initialization in the constructor.

For the sparse matrix, it is not intended for small (less than 100x100) matrices.

Storage uses the Compressed Sparse Row (CSR) format.

constructors:
- `SparseMatrix()`
- `SparseMatrix(SparseMatrix)`


- `+` addition of two matrices.
- `-` subtraction of two matrices, or negation.
- `*` matrix multiplication.
- `%` element-wise multiplication.
- `==` element-wise equality evaluation.
- `!=` element-wise non-equality evaluation.
- `>=` element-wise greater than or equal to evaluation.
- `<=` element-wise less than or equal to evaluation.
- `>` element-wise greater than evaluation.
- `<` element-wise less than evaluation.

member functions:

- `rows()` returns number of rows.
- `cols()` returns number of cols.
- `is_empty()` returns if the matrix is empty.
- `zeros()` sets all elements to zero.
- `eye()` sets all elements on the main diagonal to 1, all else to 0.
- `reset()` sets the size to 0, removing all elements.







Accessing elements
===

element access is achieved with overloaded parentheses operators, for example `a(1,2)`.


functions that operate on matrices
===

- `accumulate(matrix)` returns the sum of all elements.
- `det(matrix)` returns the determinant of the matrix, based on LU decomposition.
- `rank(matrix)` returns the rank of the matrix, based on singular value decomposition.
- `transpose(matrix)` returns the transposition of the matrix.
- `trace(matrix)` returns the sum of the diagonal elements of the matrix.
- `cross(vector, vector)` returns result of cross product of two 3-dimensional vectors (enforces matrix shape).
- `dot(vector, vector)` returns the result of dot product of two 3-dimensional vectors (enforces matrix shape).




Decompositions, factorisations, inverses and equation solvers
===


Dense
---



Sparse
---




Aliases
===

```cpp
template <typename Scalar>
using Matrix3T = math::Matrix<Scalar, 3, 3>;
template <typename Scalar>
using Matrix6T = math::Matrix<Scalar, 6, 6>;

using Matrix3f = math::Matrix<float, 3, 3>;
using Matrix4f = math::Matrix<float, 4, 4>;

template <typename Scalar>
using Vector3T = math::Matrix<Scalar, 1, 3>;
template <typename Scalar>
using Vector6T = math::Matrix<Scalar, 1, 6>;

using Vector3f = math::Matrix<float, 1, 3>;
using Vector4f = math::Matrix<float, 1, 4>;
```




BLAS
===


Level 1
---

- `sasum`, `dasum`
- `scasum`, `dzasum`
- `_nrm2`
- `i_amax`
- `_dot`, `_dotu`, `_dotc`
- `dsdot`, `sdsdot`
- `_copy`
- `_swap`
- `_scal`, `csscal`, `zdscal`
- `_axpy`
- `_rot`, `_rotm`, `csrot`, `zdrot`
- `_rotg`, `_rotmg`


Level 2
---

- `_t_mv`
- `_t_sv`
- `_g_mv`, _s_mv`, `_h_mv`
- `_g_r`, `_g_ru`, `_g_rc`
- `_s_r`, `_h_r`
- `_s_r2`, _h_r2`


Level 3
---

- `_t_mm`
- `_t_sm`
- `_g_mm`, `_s_mm`, `_h_mm`
- `_s_rk`, `_h_rk`
- `_s_r2k`, `_h_r2k`

